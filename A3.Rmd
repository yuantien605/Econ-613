---
title: "A3"
author: "Yuan Tien"
date: "3/3/2022"
output: html_document
---

```{r}
library(dplyr)
library(tidyr)
library(data.table)

getwd()
setwd("/Users/yuantien/Desktop/R/613/Data")
list.files()

datstu <- fread("datstu_v2.csv")
datsch <- fread("datsss.csv")
geo    <- fread("datjss.csv")
datsss <- fread("datsss.csv")

```

Exercise 1  
1.1
```{r}
programs <- datstu[,11:16] #select all progran choices from the dataset
programs <- unlist(programs, use.names = FALSE) #turn programs from choice 1 to choice 6 into a vector

uniprog <- unique(programs)

Num <- data.frame(no._student = nrow(datstu), 
                  no._school  = length(unique(datsch$schoolcode)),
                  no._program = length(uniprog) )
Num
```
1.2
unique school - program dyads
Can I just paste school choice with corresponding dyads and find the unique ones?
```{r}
matchoice1 <- datstu%>%
  select(schoolcode1, choicepgm1)

matchoice2 <- datstu%>%
  select(schoolcode2, choicepgm2)

matchoice3 <- datstu%>%
  select(schoolcode3, choicepgm3)

matchoice4 <- datstu%>%
  select(schoolcode4, choicepgm4)

matchoice5 <- datstu%>%
  select(schoolcode5, choicepgm5)

matchoice6 <- datstu%>%
  select(schoolcode6, choicepgm6)

#apropos() 

allchoice <- do.call("rbind", list(matchoice1, matchoice2, matchoice3, matchoice4, matchoice5, matchoice6, use.names=FALSE))

choice <- unique(allchoice)
nrow(choice) #3086 unique school - programs dyads
```

1.3 
#need check! 
apply to schools near home
idea: write a function to determine one person at a time, and then sapply to all people

```{r}
schdis <- datsch %>%
  select(schoolcode, sssdistrict)
schdis <- schdis[!duplicated(schdis$schoolcode),] #This is a list of schools with corresponding district

#Right now I can join the school dataset 

applyhome <- function(x) {
  one <- datstu[x,c(5:10, 17)] #take the person's school choice and home district
  onelong <- pivot_longer(one, !jssdistrict, values_to = "schoolcode")
  onelong <- onelong %>%
    select(jssdistrict, schoolcode)
  onet <- onelong %>%
    left_join(schdis, by = "schoolcode")
  sum(onet$jssdistrict == onet$sssdistrict)
} 

totapphome <- sapply(1:nrow(datstu), applyhome) #This takes a lot of time
length (totapphome) 
x <- totapphome >= 1 #Since the number indicates how many schools applied are in the home district, >1 captures all cases that match the question 
table(x) #250806 individuals apply to at least a school in his/her home district

#Or, maybe I can replace all schoolcode with corresponding location 2. and then just look at whether one of the 6 locations equal the jssdistrict
```

1.4

```{r}

#I calculate the number of schools admitted students by their rank. For example, to calculate how many students Duke admitted, I add up the number of students get admitted when Duke is their 1st - 6th choice.

try <- datstu %>%
  select(c(5:10,18)) 

try$admit_1 <- ifelse(try$rankplace == 1, try$schoolcode1, 0)
ch1 <- count(try, admin = admit_1) #first choices

try$admit_2 <- ifelse(try$rankplace == 2, try$schoolcode1, 0)
ch2 <- count(try, admin = admit_2) 

try$admit_3 <- ifelse(try$rankplace == 3, try$schoolcode1, 0)
ch3 <- count(try, admin = admit_3) 

try$admit_4 <- ifelse(try$rankplace == 4, try$schoolcode1, 0)
ch4 <- count(try, admin = admit_4) 

try$admit_5 <- ifelse(try$rankplace == 5, try$schoolcode1, 0)
ch5 <- count(try, admin = admit_5) 

try$admit_6 <- ifelse(try$rankplace == 6, try$schoolcode1, 0)
ch6 <- count(try, admin = admit_6) 

school_admin <- bind_rows(ch1, ch2, ch3, ch4, ch5, ch6) %>%
  group_by(admin) %>%
  summarise( sum(n) )

colnames(school_admin) <- c("schoolcode", "admitted number of students")

schoolist <- datsch %>%
  filter(duplicated(schoolcode) == FALSE) %>%
  select(schoolcode, schoolname) %>%
  left_join(school_admin, by = "schoolcode")

schoolist #NA represents no admission
```

1.5
To calculate the cutoff of each senior high schools and later on the quality of senior high, I will first create a column showing the student's admitted school.

I use my "try" dataframe I created earlier to do this. The try dataframe has six separate columns (for 6 school choices) showing each student's admitted school's school code. If Mike is admitted to his 3rd dream school of schoolcode 98021, the admit_3 column will show "98021" while admit_1, admit_2....will show 0.

```{r}
admit <- try[,8:13] #select admit_1 to admit_6
admit$admit_school = rowSums(admit) 
#Since columns outside of student's admitted school's rank will show 0, by adding all the columns I get the school they are admitted to

datstu_ad <- cbind(datstu, admit_school = admit$admit_school)

datstu_ad %>%
  group_by(admit_school) %>%
  summarise(min(score))  #Note that school "0" indicates a pool of people who didn't get admitted to any senior high schools 
```
1.6

```{r}
datstu_ad %>%
  group_by(admit_school) %>%
  summarise( mean(score) )


```

Exercise 2 - Data

During 1.2, I have already compiled a school-program level dataset named "choice". I will continue to use this. 
```{r}
choice <- rename(choice, schoolcode = schoolcode1, program = choicepgm1)

colnames(geo)
geo <- geo %>% 
  select(jssdistrict, point_x, point_y) %>%
  rename(sssdistrict = jssdistrict ) #I should recheck this!!

cutoff <- datstu_ad %>%
  group_by(admit_school) %>%
  summarise(min(score)) %>%
  rename(schoolcode = admit_school, cutoff = "min(score)")

quality <- datstu_ad %>%
  group_by(admit_school) %>%
  summarise( mean(score) )%>%
  rename(schoolcode = admit_school, quality = "mean(score)")

schpro <- choice %>%
  left_join(schdis, by = "schoolcode") %>%
  left_join(geo, by = "sssdistrict") %>%
  left_join(cutoff, by = "schoolcode") %>%   #note that this cutoff is for school not school-program level
  left_join(quality, by = "schoolcode") %>%  #note that this quality is for school not school-program level
  left_join(schoolist, by = "schoolcode")   #note that this student count is for school not school-program level
```

Since the professor may want school-program level answer, I have a new version: 

```{r}
#Calculate the school program level
try2 <- datstu %>%
  mutate(schpro1 = paste0(schoolcode1, choicepgm1), schpro2 = paste0(schoolcode2, choicepgm2), 
         schpro3 = paste0(schoolcode3, choicepgm3), schpro4 = paste0(schoolcode4, choicepgm4),
         schpro5 = paste0(schoolcode5, choicepgm5), schpro6 = paste0(schoolcode6, choicepgm6)) %>%
  select(2:4, 18:24) #just select useful column

try2$admit1 <- ifelse(try2$rankplace == 1, try2$schpro1, NA)

try2$admit2 <- ifelse(try2$rankplace == 2, try2$schpro2, NA)

try2$admit3 <- ifelse(try2$rankplace == 3, try2$schpro3, NA)

try2$admit4 <- ifelse(try2$rankplace == 4, try2$schpro4, NA)
 
try2$admit5 <- ifelse(try2$rankplace == 5, try2$schpro5, NA)

try2$admit6 <- ifelse(try2$rankplace == 6, try2$schpro6, NA)

try2 <- try2 %>%
  unite("admit", admit1, admit2, admit3, admit4, admit5, admit6, na.rm=TRUE, remove = FALSE) #use unite to past multiple columns 

schpro_admit <- as.data.frame( table(try2$admit) ) 
schpro_admit[1,1] <- as.factor("no school or program")

colnames(schpro_admit) <- c("admit", "count")

#this shows how many people are admitted to each school - program
```


```{r}
schpro_cutqua <- try2 %>%
  group_by(admit) %>%
  summarise(cutoff = min(score), quality = mean(score) )

schpro_admit <- schpro_admit %>%
  full_join(schpro_cutqua, by = "admit")

choice2 <- choice %>%
  mutate(admit = paste0(schoolcode, program))

SP <- choice2 %>%
  left_join(schdis, by = "schoolcode") %>%
  left_join(datsss, by = "sssdistrict") %>%
  left_join(schpro_admit, by = "admit") 

SP <- rename(SP, sch_n_pgm = admit) 

#This SP dataset contains cutoff, quality, and size of school-program. If a school-program has NA in cutoff, quality, or size, it means no student is admitted.  
```

Exercise 3 Distance

I already compile a "datstu_ad" dataframe that contains the school each student gets admitted to. 
```{r}
datstu_ad <- rename(datstu_ad, schoolcode = admit_school)

jss <- fread("datjss.csv") #I am reloading thess again to make sure I didn't change sth. 
sss <- fread("datsss.csv")

sss <- sss[!duplicated(sss$schoolcode),] #filter out duplicate rows

jss <- jss %>%
  rename(jsslong = point_x, jsslat = point_y)

dis_stu <- datstu_ad %>%
  left_join(sss, by = "schoolcode") %>%      #information on admitted senior high school
  left_join(jss, by = "jssdistrict") %>%     #info on junior high school
  select(ssslong, jsslong, jsslat, ssslat) #select useful columns

dis_stu <- dis_stu %>%
  mutate(dist = sqrt( (69.172*(ssslong - jsslong) * cos(jsslat/57.3)) ^2  +  (69.172 * (ssslat - jsslat))^2 ))

#the dist column shows the computed distance

```

Exercise 4

```{r}
try3 <- datstu 
try3$scode_rev1 <- substr(try3$schoolcode1, 1, 3) 
try3$scode_rev2 <- substr(try3$schoolcode2, 1, 3) 
try3$scode_rev3 <- substr(try3$schoolcode3, 1, 3) 
try3$scode_rev4 <- substr(try3$schoolcode4, 1, 3) 
try3$scode_rev5 <- substr(try3$schoolcode5, 1, 3)
try3$scode_rev6 <- substr(try3$schoolcode6, 1, 3) 

#I initially want to do it in a pipeline but it returns "unused argument" all the time

arts <- c("General Arts", "Visual Arts")
economics <- c("Business", "Home Economics")
science <- "General Science"

try3 <- within(try3, {
  pgm_rev1 = "others"
  pgm_rev1[choicepgm1 %in% arts] = "arts"
  pgm_rev1[choicepgm1 %in% economics] = "economics"
  pgm_rev1[choicepgm1 %in% science] = "science"
  pgm_rev1[is.na(pgm_rev1) == T] = "others"
  
  pgm_rev2 = "others"
  pgm_rev2[choicepgm2 %in% arts] = "arts"
  pgm_rev2[choicepgm2 %in% economics] = "economics"
  pgm_rev2[choicepgm2 %in% science] = "science"
  pgm_rev2[is.na(pgm_rev2) == T] = "others"
  
  pgm_rev3 = "others"
  pgm_rev3[choicepgm3 %in% arts] = "arts"
  pgm_rev3[choicepgm3 %in% economics] = "economics"
  pgm_rev3[choicepgm3 %in% science] = "science"
  pgm_rev3[is.na(pgm_rev3) == T] = "others"
  
  pgm_rev4 = "others"
  pgm_rev4[choicepgm4 %in% arts] = "arts"
  pgm_rev4[choicepgm4 %in% economics] = "economics"
  pgm_rev4[choicepgm4 %in% science] = "science"
  pgm_rev4[is.na(pgm_rev4) == T] = "others"
  
  pgm_rev5 = "others"
  pgm_rev5[choicepgm5 %in% arts] = "arts"
  pgm_rev5[choicepgm5 %in% economics] = "economics"
  pgm_rev5[choicepgm5 %in% science] = "science"
  pgm_rev5[is.na(pgm_rev5) == T] = "others"
  
  pgm_rev6 = "others"
  pgm_rev6[choicepgm6 %in% arts] = "arts"
  pgm_rev6[choicepgm6 %in% economics] = "economics"
  pgm_rev6[choicepgm6 %in% science] = "science"
  pgm_rev6[is.na(pgm_rev6) == T] = "others"
})

#Be caution that if a student does not submit a choice (choice = NA) , it will be considered "others" 
```

Choice variable 
```{r}
try3 <- try3 %>%
  mutate(choice_rev1 = paste0(scode_rev1, pgm_rev1), choice_rev2 = paste0(scode_rev2, pgm_rev2), 
         choice_rev3 = paste0(scode_rev3, pgm_rev3), choice_rev4 = paste0(scode_rev4, pgm_rev4),
         choice_rev5 = paste0(scode_rev5, pgm_rev5), choice_rev6 = paste0(scode_rev6, pgm_rev6))
```

Compute new quality and cutoff
```{r}

cutqua <- function(x) {
x$admit1 <- ifelse(x$rankplace == 1, x$choice_rev1, NA)
x$admit2 <- ifelse(x$rankplace == 2, x$choice_rev2, NA)
x$admit3 <- ifelse(x$rankplace == 3, x$choice_rev3, NA)
x$admit4 <- ifelse(x$rankplace == 4, x$choice_rev4, NA)
x$admit5 <- ifelse(x$rankplace == 5, x$choice_rev5, NA)
x$admit6 <- ifelse(x$rankplace == 6, x$choice_rev6, NA)

x <- x %>%
  unite("admit", admit1, admit2, admit3, admit4, admit5, admit6, na.rm=TRUE, remove = FALSE)

x %>%
  group_by(admit) %>%
  summarise(cutoff = min(score), quality = mean(score) )

}

cutqua(try3) #This will show the cutoff and quality of each newly compiled school - program category
```

Consider the 20,000 highest score students

```{r}
try4 <- try3[order(-score), ] #negative sign means descending
try4 <- try4[1:20000,]
```

Exercise 5

Note that the first choice is choice_rev1
First choice is a catego
```{r}
length(unique(try4$choice_rev1))
# Dependent Variable: choice_rev1, categorical, 246 choices
# Independent Variable: test score, continuous
# Since we are dealing with student characteristic and their preference of school-program, we should use multinomial logit. 

try5<- try4

try5$choice_rev1 <- as.numeric( as.factor(try5$choice_rev1) )

name_list <- try4 %>%      #this list stores the factor number and corresponding school-pgm name
  select(choice_rev1) %>%
  cbind(try5$choice_rev1)

like_fun1 <- function(par, try5) {
  choice_rev1 = try5$choice_rev1
  score = try5$score

  n_i = nrow(try5) #should be 20,000 students
  n_j = length(unique(try5$choice_rev1)) #246 choices
  out = mat.or.vec( n_i,n_j )
  #This out should eventually contain the imagined utility for every individual and their potential choice 
  
  #remember to omit a choice as the reference choice
  n_jref = n_j - 1 
  
  #Since restrict Beta_omitted_choice = 0 means the choice essentially has no effect on utility, I can set the utility of that choice to 0 to represent restriction
  out[,1] = 0
  
  #parameter set for every right-hand side variables and intercept
  par_set1 = par[1:n_jref]  
  par_set2 = par[ (n_jref+1) : (2*n_jref) ]

  for (j in 2:n_j) { #remember out[,1] should be 0, so we should start from the second column 
    out[,j] = par_set1[(j-1)] + par_set2[j-1] * score 
  }
  
  #transform the utility to form logit probility
  prob = exp(out)
  prob = sweep(prob, MARGIN=1, FUN="/", STATS=rowSums(prob)) 
  #margin = 1 means operate by row. This sweeps function means we do every exp(XiBj)/ (exp(XiBj) + exp(XiBe) +exp(XiBk)...) by row

  prob_choice = NULL
for (i in 1:n_i){
    prob_choice[i] = prob[i, choice_rev1[i] ] #prob_choice as the probability of individual i chooses his/her actual choice
  }
  prob_choice[prob_choice >0.999999] = 0.999999
  prob_choice[prob_choice <0.000001] = 0.000001 # To prevent prob from going to negative or above one
  like = sum( log(prob_choice) )
  return(- like) #remember I already has a minus here
}


(246 -1)*2 # = 490 parameters to estimate

# since it takes forever to optimize once, I choose to store the result of my first attempt 
searchv = runif(490, -1, 1) 

result  = optim(searchv, fn = like_fun1, method = "BFGS", 
                  control = list(trace = 6, maxit = 3000),
                  try5 = try5) #leave out "par" because "par" is what we want to estimate
first_estimate = result$par
first_like = result$value #274486.6

result  = optim(searchv, fn = like_fun1, method = "BFGS", 
                  control = list(trace = 6, maxit = 3000),
                  try5 = try5, hessian = TRUE)
second_estimate = result$par
second_like = result$value

#final  value 261845.372652 
#the second attempts takes more than two hours so I stop
```

```{r}
#Because simply choosing random search value takes too long, I choose to use multinom to guide me through searching value
options(scipen=999) #prevent scientific notations
library(nnet)

pack_res = multinom(choice_rev1 ~ score, data= try5)

pack_coef <- as.data.frame( coef(pack_res) )
  
pack_search <- c(pack_coef$`(Intercept)`, pack_coef$score)
# this vector list the 245 intercept estimates and then 245 choice:score estimates
```
```{r}

result3  = optim(pack_search, fn = like_fun1, method = "BFGS", 
                  control = list(trace = 6, maxit = 3000),
                  try5 = try5)
result3$value #likelihood: - 73620.09
result3$par


```

